'''
This class uses objects of the class 'Slot' to build schedules that can be processed by the constraint handling classes
and placed into the tree structure generated by the Tree class. Every object in the schedule must be of the class 'Slot'.

'''"""
This class uses objects of the class 'Slot' to build schedules that can be processed by the constraint-handling
classes and placed into the tree structure generated by the Tree class. Every object in the schedule must be of
the class 'Slot'.
"""

import copy

from Search.Layout import Layout
from Enumerations import ActivityType, Weekday


class Schedule:

    def __init__(self) -> None:
        """
                Initializes a Schedule object with default values for assignments, slots, and activities.
                It also calculates the initial evaluation score based on penalties and preferences.
                """
        # Maps each slot ID to a set of activities assigned to that slot
        self.assignments = {slot_id: set() for slot_id in Layout.ALL_SLOT_IDS}
        # Maps each activity ID to the slot ID it is assigned to
        self.slot_of_each_activity = {}  # maps from activity id to slot id to represent which slot each activity is scheduled to
        self.latest_assignment = None  # (activity id, slot id)

        # Identify vacant slots for games and practices
        self.vacant_game_slots = set(
            filter(lambda id: Layout.SLOT_ID_TO_OBJ[id].gamemax > 0, Layout.GAME_SLOT_IDS))
        self.vacant_practice_slots = set(
            filter(lambda id: Layout.SLOT_ID_TO_OBJ[id].practicemax > 0, Layout.PRACTICE_SLOT_IDS))
        self.vacant_slots = self.vacant_game_slots.union(self.vacant_practice_slots)
        self.remaining_games = list(Layout.GAME_IDS)  # TODO: needs to initialized to be the entire set of games
        self.remaining_practices = list(
            Layout.PRACTICE_IDS)  # TODO: needs to be initialized to be the entire set of practices
        self.eval = 0  # Evaluation score of the schedule, based on constraints and preferences

        # Calculate penalties based on minimum game and practice requirements
        gamemin_sum = 0
        for slot_id in self.vacant_game_slots:
            slot_object = Layout.SLOT_ID_TO_OBJ[slot_id]
            gamemin_sum = gamemin_sum + slot_object.gamemin

        practicemin_sum = 0
        for slot_id in self.vacant_practice_slots:
            slot_object = Layout.SLOT_ID_TO_OBJ[slot_id]
            practicemin_sum = practicemin_sum + slot_object.practicemin

        gamemin_eval = gamemin_sum * Layout.PEN_GAMEMIN
        practicemin_eval = practicemin_sum * Layout.PEN_PRACTICEMIN

        # Calculate the preference evaluation score
        preference_eval = 0
        for tp in Layout.PREFERENCES.values():
            for preference in tp:
                preference_eval = preference_eval + preference[1]
        # Total evaluation score
        self.eval = gamemin_eval + practicemin_eval + preference_eval

    """
        Creates a deep copy of the schedule, preserving its current state.
        """

    def get_copy(self):
        return copy.deepcopy(self)

    def get_activities_in_slot(self, slot_id: "tuple[ActivityType, Weekday, str]") -> "set[str]":
        """
            Retrieves the set of activities assigned to a specific slot.

            :param slot_id: Tuple representing the slot's type, weekday, and time.
            :return: Set of activity IDs assigned to the slot.
            """
        return self.assignments[slot_id]

    def getEval(self):
        """
            Returns the evaluation score of the schedule.
            """
        return self.eval

    def assign_activity(self, activity_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        """
        Assigns an activity to a slot. Determines whether the activity is a game or practice
        and delegates to the corresponding method.

        :param activity_id: ID of the activity to assign.
        :param slot_id: ID of the slot to assign the activity to.
        """
        activity_type = Layout.ACTIVITY_ID_TO_OBJ[activity_id].ACTIVITY_TYPE

        if activity_type == ActivityType.GAME:
            self.assign_game(activity_id, slot_id)
        elif activity_type == ActivityType.PRACTICE:
            self.assign_practice(activity_id, slot_id)
        else:
            raise (RuntimeError("Invalid activity type of slot ID in 'assign_activity()' method"))

    def assign_game(self, game_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        """
        Assigns a game to a specific slot and updates schedule state.

        :param game_id: ID of the game to assign.
        :param slot_id: ID of the slot where the game is assigned.
        """
        self.assignments[slot_id].add(game_id)
        self.slot_of_each_activity[game_id] = slot_id
        self.latest_assignment = (game_id, slot_id)
        self.remaining_games.remove(game_id)  # if this line causes errors, maybe try a reassignment
        # print("Games left: " + str(self.remaining_games))

        slot_obj = Layout.SLOT_ID_TO_OBJ[slot_id]
        slot_type = slot_obj.ACTIVITY_TYPE
        if slot_type == ActivityType.GAME and len(self.assignments[slot_id]) >= slot_obj.gamemax:
            self.vacant_slots.remove(slot_id)
            self.vacant_game_slots.remove(slot_id)
        if slot_type == ActivityType.PRACTICE and len(self.assignments[slot_id]) >= slot_obj.practicemax:
            self.vacant_slots.remove(slot_id)
            self.vacant_practice_slots.remove(slot_id)

    def assign_practice(self, practice_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        """
        Assigns a practice to a specific slot and updates schedule state.

        :param practice_id: ID of the practice to assign.
        :param slot_id: ID of the slot where the practice is assigned.
        """
        # print("Practice: " + practice_id)
        # print("Slot: " + str(slot_id))
        # print("Remaining games: " + str(self.remaining_games))
        # print("Remaining practices: " + str(self.remaining_practices))
        # print()
        self.assignments[slot_id].add(practice_id)
        self.slot_of_each_activity[practice_id] = slot_id
        self.latest_assignment = (practice_id, slot_id)
        self.remaining_practices.remove(practice_id)  # if this line causes errors, maybe try a reassignment
        # print("Practices left: " + str(self.remaining_practices))

        slot_obj = Layout.SLOT_ID_TO_OBJ[slot_id]
        slot_type = slot_obj.ACTIVITY_TYPE
        if slot_type == ActivityType.GAME and len(self.assignments[slot_id]) >= slot_obj.gamemax:
            self.vacant_slots.remove(slot_id)
            self.vacant_game_slots.remove(slot_id)
        if slot_type == ActivityType.PRACTICE and len(self.assignments[slot_id]) >= slot_obj.practicemax:
            self.vacant_slots.remove(slot_id)
            self.vacant_practice_slots.remove(slot_id)
