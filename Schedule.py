"""
This class uses objects of the class 'Slot' to build schedules that can be processed by the constraint-handling
classes and placed into the tree structure generated by the Tree class. Every object in the schedule must be of
the class 'Slot'.
"""

import copy
from Search.Layout import Layout
from Enumerations import ActivityType, Weekday


class Schedule:

    def __init__(self) -> None:
        """
        Initializes a Schedule object with default values for assignments, slots, and activities.
        It also calculates the initial evaluation score based on penalties and preferences.
        """
        # Maps each slot ID to a set of activities assigned to that slot
        self.assignments = {slot_id: set() for slot_id in Layout.ALL_SLOT_IDS}

        # Maps each activity ID to the slot ID it is assigned to
        self.slot_of_each_activity = {}

        # Tracks the latest assignment made to the schedule (activity ID, slot ID)
        self.latest_assignment = None

        # Identify vacant slots for games and practices
        self.vacant_game_slots = set(
            filter(lambda id: Layout.SLOT_ID_TO_OBJ[id].gamemax > 0, Layout.GAME_SLOT_IDS)
        )
        self.vacant_practice_slots = set(
            filter(lambda id: Layout.SLOT_ID_TO_OBJ[id].practicemax > 0, Layout.PRACTICE_SLOT_IDS)
        )
        self.vacant_slots = self.vacant_game_slots.union(self.vacant_practice_slots)

        # Initialize the list of remaining games and practices
        self.remaining_games = list(Layout.GAME_IDS)
        self.remaining_practices = list(Layout.PRACTICE_IDS)

        # Evaluation score of the schedule, based on constraints and preferences
        self.eval = 0

        # Calculate penalties based on minimum game and practice requirements
        gamemin_sum = sum(Layout.SLOT_ID_TO_OBJ[slot_id].gamemin for slot_id in self.vacant_game_slots)
        practicemin_sum = sum(Layout.SLOT_ID_TO_OBJ[slot_id].practicemin for slot_id in self.vacant_practice_slots)

        gamemin_eval = gamemin_sum * Layout.PEN_GAMEMIN
        practicemin_eval = practicemin_sum * Layout.PEN_PRACTICEMIN

        # Calculate the preference evaluation score
        preference_eval = sum(
            sum(preference[1] for preference in preferences)
            for preferences in Layout.PREFERENCES.values()
        )

        # Total evaluation score
        self.eval = gamemin_eval + practicemin_eval + preference_eval

    def get_copy(self):
        """
        Creates a deep copy of the schedule, preserving its current state.
        """
        return copy.deepcopy(self)

    def get_activities_in_slot(self, slot_id: "tuple[ActivityType, Weekday, str]") -> "set[str]":
        """
        Retrieves the set of activities assigned to a specific slot.

        :param slot_id: Tuple representing the slot's type, weekday, and time.
        :return: Set of activity IDs assigned to the slot.
        """
        return self.assignments[slot_id]

    def getEval(self):
        """
        Returns the evaluation score of the schedule.
        """
        return self.eval

    def assign_activity(self, activity_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        """
        Assigns an activity to a slot. Determines whether the activity is a game or practice
        and delegates to the corresponding method.

        :param activity_id: ID of the activity to assign.
        :param slot_id: ID of the slot to assign the activity to.
        """
        activity_type = Layout.ACTIVITY_ID_TO_OBJ[activity_id].ACTIVITY_TYPE

        if activity_type == ActivityType.GAME:
            self.assign_game(activity_id, slot_id)
        elif activity_type == ActivityType.PRACTICE:
            self.assign_practice(activity_id, slot_id)
        else:
            raise RuntimeError("Invalid activity type in 'assign_activity' method.")

    def assign_game(self, game_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        """
        Assigns a game to a specific slot and updates schedule state.

        :param game_id: ID of the game to assign.
        :param slot_id: ID of the slot where the game is assigned.
        """
        # Add the game to the slot's assignments and update mappings
        self.assignments[slot_id].add(game_id)
        self.slot_of_each_activity[game_id] = slot_id
        self.latest_assignment = (game_id, slot_id)

        # Remove the game from the remaining games
        self.remaining_games.remove(game_id)

        # Check if the slot is now fully utilized
        slot_obj = Layout.SLOT_ID_TO_OBJ[slot_id]
        if len(self.assignments[slot_id]) >= slot_obj.gamemax:
            self.vacant_slots.remove(slot_id)
            self.vacant_game_slots.remove(slot_id)

    def assign_practice(self, practice_id: str, slot_id: "tuple[ActivityType, Weekday, str]"):
        """
        Assigns a practice to a specific slot and updates schedule state.

        :param practice_id: ID of the practice to assign.
        :param slot_id: ID of the slot where the practice is assigned.
        """
        # Add the practice to the slot's assignments and update mappings
        self.assignments[slot_id].add(practice_id)
        self.slot_of_each_activity[practice_id] = slot_id
        self.latest_assignment = (practice_id, slot_id)

        # Remove the practice from the remaining practices
        self.remaining_practices.remove(practice_id)

        # Check if the slot is now fully utilized
        slot_obj = Layout.SLOT_ID_TO_OBJ[slot_id]
        if len(self.assignments[slot_id]) >= slot_obj.practicemax:
            self.vacant_slots.remove(slot_id)
            self.vacant_practice_slots.remove(slot_id)
